# Ugly Number II

Illustration: **Generate n th ugly number, whose prime factor only with 2, 3, 5**

Solution: **Pointer-based number generation**


## Solution Insights 
There is ordering relation between ugly numbers. For each time, we want to maintain the order and generate a new ugly number which is the next biggest one. Also, we need to maintain the uniqueness when generating numbers. Since 2, 3, 5 are relatively independent and it is clear the next ugly number is generated by multiplying 2, 3 or 5 with previous ugly numbers, we can maintain three pointers to track the next multiple numbers and select the smallest for our next generated ugly number. The pointers also need to be updated due to uniqueness requirement.

## Solution Implementation
Three pointers with generation update

Solution Sample (Python - dict with list):
```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        # generate method for ugly number
        presentUglyNumbers = list([1])
        pointer2, pointer3, pointer5 = 0, 0, 0
        nextGenerate2 = presentUglyNumbers[pointer2] * 2
        nextGenerate3 = presentUglyNumbers[pointer3] * 3
        nextGenerate5 = presentUglyNumbers[pointer5] * 5
        
        while len(presentUglyNumbers) < n:
            presentMin = min(nextGenerate2, nextGenerate3, nextGenerate5)
            presentUglyNumbers.append(presentMin)
            # the reason to use if instead of elif is due to the uniqueness
            if presentMin == nextGenerate2:
                pointer2 += 1
                nextGenerate2 = presentUglyNumbers[pointer2] * 2
            if presentMin == nextGenerate3:
                pointer3 += 1
                nextGenerate3 = presentUglyNumbers[pointer3] * 3
            if presentMin == nextGenerate5:
                pointer5 += 1
                nextGenerate5 = presentUglyNumbers[pointer5] * 5
        return presentUglyNumbers[-1]
```
